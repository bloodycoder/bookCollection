通读一遍书，把一些没见过的概念记录一下。并不系统。

### 移动构造函数

    class A{
        A(A&&){}
    };

你在函数调用返回值得时候，调用的就是移动构造函数。用move函数可以获得。

move函数，实际上是`static_cast<A&&>(tem)`的一个封装。

### 初始化和析构的顺序

初始化:基类构造->成员构造->函数体

析构顺序:函数体->成员析构->基类析构

初始化的时候，顺序应该填声明的顺序。

这也是为什么把成员初始化不放在构造函数函数体里，效率会高的原因。

### new运算符重载

如果你重载了new运算符，并且指定了内存的位置，那么就需要显示地析构。

### 用"{1,2}"来构造你的实例

意思是
    class A(){
        A(){
            pass;
        }
    }
让A能够接受A={1,2,3,4}这样的输入。

只需在A的构造函数定义成
    A(initializer_list<T>)
即可。

### 关键字explicit

意思是
    class A(){
        A(){
            pass;
        }
    }
然后我们执行`A a = 12`.

由于12是int,而a是A类型。所以编译器进行隐式类型转换，实际执行的是`A a = A(12);`

如果我们在A的构造函数前加入`explicit` 关键字，那么编译器会拒绝隐式类型转换，这段就会报错。

### '{}'和'()'的小区别

vector<double>v1(7) 7个元素的vector
vector<double>v1{7} 1个元素的vector,值为7

### static成员的初始化

当类有一个static成员，初始化在类的外部。

但也有例外，比如const static.你只能在内部初始化。

### 如果一个类被用作基类，防止切片问题。

### 一个类有虚函数，则它也需要一个虚析构函数

如果有虚函数，说明涉及多态。那么就有可能出现，delete的时候内存泄漏。所以必须也用虚析构函数。

### 显示定义默认构造函数，以及删除构造函数

    class A{
        A() = default;
    }
    class A{
        A() = delete;
    }

一个类可以在构造函数中初始化基类，但不能初始化基类的基类。
